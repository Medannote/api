from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse, StreamingResponse
import wfdb
import matplotlib.pyplot as plt
import pandas as pd
import os
import numpy as np
import glob
import uuid
import tempfile
import zipfile
import io
from typing import List, Dict, Optional
from pathlib import Path

app = FastAPI(
    title="API de Traitement de Signaux Médicaux",
    description="API pour analyser et traiter des signaux médicaux au format WFDB",
    version="1.0.0"
)

# Fonctions de traitement des signaux (adaptées de votre code)
def afficher_toutes_metadonnées(signal_path: str) -> Dict:
    """Affiche toutes les métadonnées disponibles d'un signal médical."""
    try:
        record = wfdb.rdheader(signal_path)
        return record.__dict__
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors de la lecture des métadonnées : {e}")

def stocker_csv(folder_path: str) -> pd.DataFrame:
    """
    Extrait les métadonnées de tous les signaux WFDB d'un dossier
    et les renvoie sous forme d'un DataFrame pandas.
    """
    all_metadata = []
    
    # Parcourt tous les fichiers .hea dans le dossier
    hea_files = glob.glob(os.path.join(folder_path, '*.hea'))
    
    if not hea_files:
        raise HTTPException(status_code=404, detail=f"Aucun fichier .hea trouvé dans le dossier : {folder_path}")
    
    for file_path in hea_files:
        signal_name = os.path.basename(file_path).replace('.hea', '')
        
        try:
            record = wfdb.rdheader(os.path.join(folder_path, signal_name))
            
            metadata_dict = {'signal_name': signal_name}
            for key, value in record.__dict__.items():
                if key.startswith('_') or key in ['e_p_signal', 'e_p_sig_name']:
                    continue
                
                if isinstance(value, (list, tuple)):
                    value = str(value)
                
                metadata_dict[key] = value
            
            all_metadata.append(metadata_dict)
            
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erreur lors du traitement du signal '{signal_name}' : {e}")
    
    return pd.DataFrame(all_metadata)

def plot_signal(signal_path: str) -> io.BytesIO:
    """Lit et trace le graphique du signal, retourne l'image en mémoire."""
    try:
        record = wfdb.rdrecord(signal_path)
        
        # Créer le plot en mémoire
        buffer = io.BytesIO()
        plt.figure(figsize=(12, 6))
        wfdb.plot_wfdb(record=record, title=f"Signal médical : {record.record_name}")
        plt.savefig(buffer, format='png')
        plt.close()
        buffer.seek(0)
        
        return buffer
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du traçage du signal : {e}")

def division_df(folder_path: str) -> tuple:
    """
    Charge les métadonnées, génère un ID unique pour chaque enregistrement,
    et divise le DataFrame en deux : informations personnelles et métadonnées médicales.
    """
    df = stocker_csv(folder_path)
    
    if df is None or df.empty:
        raise HTTPException(status_code=404, detail="Aucune donnée chargée")
    
    # Générer un ID unique entier formaté sur 8 chiffres pour chaque enregistrement
    df['id'] = [f'{i:08d}' for i in range(1, len(df) + 1)]
    
    # Définir les colonnes pour les informations personnelles
    personal_info_cols = ['signal_name', 'id']
    for col in ['nom', 'prenom', 'age', 'patient_name']:
        if col in df.columns:
            personal_info_cols.append(col)
    
    # Créer le DataFrame des informations personnelles
    personal_info_df = df[personal_info_cols].copy()
    
    # Créer le DataFrame des métadonnées avec les colonnes restantes
    metadata_cols = [col for col in df.columns if col not in ['nom', 'prenom', 'age', 'patient_name']]
    metadata_df = df[metadata_cols].copy()
    
    return personal_info_df, metadata_df

# Endpoints de l'API
@app.get("/")
async def root():
    """Point d'entrée de l'API"""
    return {
        "message": "API de Traitement de Signaux Médicaux",
        "version": "1.0.0",
        "endpoints": {
            "metadata": "GET /metadata/{signal_name} - Récupère les métadonnées d'un signal",
            "plot_signal": "GET /plot/{signal_name} - Génère un graphique du signal",
            "process_folder": "POST /process_folder - Traite tous les signaux d'un dossier",
            "download_metadata": "POST /download_metadata - Télécharge les métadonnées en format CSV"
        }
    }

@app.get("/metadata/{signal_name}")
async def get_metadata(signal_name: str, folder_path: str):
    """
    Récupère les métadonnées d'un signal spécifique
    """
    try:
        full_path = os.path.join(folder_path, signal_name)
        metadata = afficher_toutes_metadonnées(full_path)
        return {"signal_name": signal_name, "metadata": metadata}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/plot/{signal_name}")
async def get_signal_plot(signal_name: str, folder_path: str):
    """
    Génère et retourne un graphique du signal spécifié
    """
    try:
        full_path = os.path.join(folder_path, signal_name)
        image_buffer = plot_signal(full_path)
        
        return StreamingResponse(
            image_buffer,
            media_type="image/png",
            headers={"Content-Disposition": f"attachment; filename={signal_name}_plot.png"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/process_folder")
async def process_folder(folder_path: str):
    """
    Traite tous les signaux d'un dossier et retourne les métadonnées
    """
    try:
        df = stocker_csv(folder_path)
        personal_df, medical_df = division_df(folder_path)
        
        return {
            "total_signals": len(df),
            "personal_info": personal_df.to_dict(orient='records'),
            "medical_metadata": medical_df.to_dict(orient='records'),
            "full_metadata": df.to_dict(orient='records')
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/download_metadata")
async def download_metadata(background_tasks: BackgroundTasks, folder_path: str):
    """
    Télécharge toutes les métadonnées des signaux sous forme de fichiers CSV dans un ZIP
    """
    try:
        # Créer un répertoire temporaire
        temp_dir = tempfile.mkdtemp()
        zip_path = os.path.join(temp_dir, "metadata.zip")
        
        # Traiter les données
        personal_df, medical_df = division_df(folder_path)
        
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            # Ajouter le CSV des informations personnelles
            personal_csv = io.StringIO()
            personal_df.to_csv(personal_csv, index=False)
            zipf.writestr("informations_personnelles.csv", personal_csv.getvalue())
            
            # Ajouter le CSV des métadonnées médicales
            medical_csv = io.StringIO()
            medical_df.to_csv(medical_csv, index=False)
            zipf.writestr("metadonnees_medicales.csv", medical_csv.getvalue())
            
            # Ajouter un fichier README
            readme_content = """# Métadonnées de Signaux Médicaux

## Fichiers inclus:
- informations_personnelles.csv : Informations d'identification des patients
- metadonnees_medicales.csv : Métadonnées techniques des signaux

## Structure des données:

### Informations personnelles:
- signal_name: Nom du fichier signal
- id: Identifiant unique du patient
- nom, prenom, age: Informations personnelles (si disponibles)

### Métadonnées médicales:
- Toutes les autres métadonnées techniques du signal
"""
            zipf.writestr("README.md", readme_content)
        
        # Nettoyer les fichiers temporaires après envoi
        def remove_temp_files():
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
        
        background_tasks.add_task(remove_temp_files)
        
        return StreamingResponse(
            open(zip_path, "rb"),
            media_type="application/zip",
            headers={"Content-Disposition": "attachment; filename=metadata_signaux_medicaux.zip"}
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/upload_signals")
async def upload_signals(background_tasks: BackgroundTasks, files: List[UploadFile] = File(...)):
    """
    Upload de fichiers de signaux médicaux (.hea et .dat) et traitement
    """
    try:
        # Créer un répertoire temporaire
        temp_dir = tempfile.mkdtemp()
        
        # Sauvegarder tous les fichiers uploadés
        for file in files:
            file_path = os.path.join(temp_dir, file.filename)
            with open(file_path, "wb") as f:
                content = await file.read()
                f.write(content)
        
        # Traiter les fichiers
        df = stocker_csv(temp_dir)
        personal_df, medical_df = division_df(temp_dir)
        
        # Nettoyer les fichiers temporaires après traitement
        def remove_temp_files():
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
        
        background_tasks.add_task(remove_temp_files)
        
        return {
            "uploaded_files": [file.filename for file in files],
            "total_signals": len(df),
            "personal_info": personal_df.to_dict(orient='records'),
            "medical_metadata": medical_df.to_dict(orient='records')
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))